オンラインコワーキングスペース リファクタリング戦略
1. 現状評価と目標設定
現状評価:

技術スタック: Next.js (App Router), TypeScript, MongoDB, Tailwind CSS, Shadcn UI, Server-Sent Events (SSE), YouTube Data API。モダンで適切な技術選定。
コード構成: app, components, lib, scripts, docs に分離されており、基本的な構造は良好。
機能: YouTubeコメント連携、コマンド処理、座席管理、リアルタイム更新 (SSE)、自動退室、ポモドーロタイマー表示、UIコンポーネント群。
潜在的な課題:
リアルタイム処理の複雑性: SSEハンドラ(api/sse/route.ts)がDB変更監視と定期的な自動退室チェックの両方を担っており、複雑化・不安定化のリスクがある。
コマンド処理の責務: api/youtube-comments/route.ts がコメント取得(GET)とDB更新(コマンド処理による副作用)の両方を行っており、REST原則から逸脱している。また、クライアント(page.tsx)からのポーリング呼び出しに依存している。
状態管理: Seat/Roomの状態は主にSSE経由で更新されるが、接続断時の復旧ロジックやクライアント側での一貫性担保が課題となる可能性がある。
ロジックの重複: ポモドーロタイマー関連ロジックが Header.tsx (時刻ベース) と PomodoroTimer.tsx (本来のタイマー) の両方に存在する可能性がある (現状 PomodoroTimer.tsx が主要に見えるが、Header.tsx の時刻ベース計算は複雑で不安定要素)。localStorage への依存も懸念。
自動退室ロジックの重複: api/check-auto-exit/route.ts と api/sse/route.ts 内のチェックロジックが重複している。
テスト: 自動テスト（ユニット、インテグレーション）が存在しない。
エラーハンドリング: 各所に try-catch はあるが、より一貫性のあるエラー報告・監視体制が必要。
型定義: lib/mongodb.ts に主要な型があるが、APIレスポンスやコンポーネントPropsなど、より網羅的な型付けが望ましい。
ドキュメント: docs フォルダは存在するが、コード変更に伴う継続的な更新が必要。
JavaScriptファイル: lib/youtube.js, scripts/test-mongodb-cjs.js など、TypeScriptプロジェクト内にJavaScriptファイルが混在している (lib/youtube.ts もあるため重複)。
リファクタリング目標:

保守性の向上: コードの可読性、理解しやすさ、変更の容易さを向上させる。
信頼性の向上: バグを減らし、エラーハンドリングを強化し、システムの安定性を高める。特にリアルタイム処理と状態管理。
パフォーマンスの最適化: APIレスポンス、データベースアクセス、フロントエンドレンダリングの効率を改善する。
テスト容易性の向上: ユニットテスト、インテグレーションテストを導入しやすくする。
関心の分離: 各コンポーネントやモジュールの責務を明確にする。
2. リファクタリング戦略（フェーズ分け）
フェーズ 0: 準備と基盤整備

テスト環境構築:
Jest / React Testing Library / Playwright 等のテストフレームワークを導入。
基本的なテストカバレッジレポート設定。
リンティング・フォーマット:
ESLint / Prettier のルールを確認・統一し、CIでのチェックを強制。
TypeScript移行:
lib/youtube.js -> lib/youtube.ts へ完全移行・統合。不要な .js ファイルを削除。
scripts 内の .js ファイルも可能な限り .ts へ移行 (ts-node 活用)。
依存関係整理:
package.json を確認し、不要な依存関係を削除。バージョンを最新安定版に更新検討。
フェーズ 1: コアロジックの整理と責務分離

ポモドーロタイマーロジック統合:
Header.tsx と PomodoroTimer.tsx のタイマーロジックを分析。
推奨: PomodoroTimer.tsx のロジックを主とし、現在時刻ベースの複雑な計算（特に determineTimeModeFromCurrentTime）は削除または大幅に簡略化する。状態管理（Context API や Zustand など）を導入し、Header と PomodoroTimer で状態を共有する。localStorage への直接依存を減らし、状態管理ライブラリ経由にする。
自動退室ロジック統合:
api/sse/route.ts 内の定期チェックを主とし、api/check-auto-exit/route.ts は削除または補助的な役割（手動トリガー等）に限定する。SSEハンドラ内のチェックロジックの安定性を高める。
YouTubeコメント処理とコマンド実行の分離:
api/youtube-comments/route.ts は コメント取得 に専念させる。GETリクエストでDB更新を行うのをやめる。
推奨:
バックエンドで独立したポーリングプロセス（例: 定期実行される別のAPIルートや、サーバーレス環境なら外部スケジューラからのWebhookトリガー）を実装し、コメントを取得。
取得したコメントをキュー（例: Vercel KV や MongoDB の一時コレクション）に入れる。
別のAPIルート (api/process-command/route.ts など）がキューからコマンドを処理し、DB更新とYouTubeへの応答メッセージ送信を行う。
これにより、コメント取得とコマンド実行の責務が分離され、GETリクエストの副作用がなくなる。
代替案（シンプル）: page.tsx の setInterval を維持し、api/youtube-comments でコメント取得。コマンド検出 後、クライアントから別の POST /api/commands エンドポイントを叩いて処理を依頼する。
フェーズ 2: リアルタイム処理の改善

SSEハンドラ (api/sse/route.ts) のリファクタリング:
MongoDB Change Stream のエラーハンドリング強化（再接続ロジックなど）。
自動退室チェックロジックをより分離・明確化。
クライアント切断時のリソースリーク防止 (isControllerClosed 周辺のロジックを再確認・簡素化）。
初期データ送信と変更ストリーム監視のコードを整理。
クライアント側SSEハンドリング (page.tsx) の改善:
EventSource のエラーハンドリング、再接続ロジックを堅牢にする。
SSEからのデータ受信・状態更新ロジックをカスタムフック (useSeatData など) に抽出し、page.tsx をクリーンにする。
フェーズ 3: フロントエンドと状態管理の改善

page.tsx の責務軽減:
SSE接続管理、YouTubeコメントポーリング（フェーズ1でバックエンド化しない場合）などのロジックをカスタムフックやContext Providerに移動。
コンポーネント粒度の見直し:
FocusRoom.tsx のアニメーションロジックが複雑な場合、状態管理ライブラリや専用のアニメーションライブラリの利用を検討。
UIコンポーネント (components/ui) はShadcnベースで問題ないが、ドメイン固有のロジックを持つコンポーネント (UserCard, FocusRoom) は適切か確認。
状態管理戦略の明確化:
現在の座席/ルームデータはSSEプッシュ型。クライアント側での状態保持、表示更新ロジックを明確にする。必要であれば Zustand や Jotai などの軽量ライブラリ導入を検討し、グローバル/共有状態を一元管理する。use-toast のようなフックも状態管理の一部と見なせる。
フェーズ 4: テストカバレッジ向上

ユニットテスト:
lib/utils.ts 内のヘルパー関数 (detectCommand, calculateRemainingTime 等）。
lib/messages.ts のテンプレート生成。
コンポーネントの表示ロジック（UserCard, PomodoroTimer など）。
インテグレーションテスト:
APIエンドポイントのテスト（Mock Service Worker や Supertest を使用）。コマンド処理、SSE接続、DB操作を含むシナリオ。
フロントエンドとバックエンドを連携させたテスト（例: コマンド送信 -> UI更新）。
E2Eテスト (オプション):
主要なユーザーフロー（入室、退室、自動退室の確認）を Playwright などで自動化。
フェーズ 5: ドキュメントとクリーンアップ

ドキュメント更新:
docs/ 内のドキュメントをリファクタリング内容に合わせて更新。
コード内のコメント（JSDoc/TSDoc）を充実させる。特にAPIや複雑なロジック。
コードクリーンアップ:
未使用の変数、関数、インポート、コンポーネントを削除。
console.log 等のデバッグコードを削除または適切なロガーに置き換え。
.env.example を作成し、必要な環境変数を明記。
3. 実施上の注意点
段階的実施: 各フェーズごとに変更をマージし、動作確認を行う。一度に大きな変更を加えない。
テスト駆動: 新しいコードやリファクタリングされたコードには必ずテストを追加する。既存機能が壊れていないことを確認するリグレッションテストが重要。
コードレビュー: すべての変更に対してチーム内でコードレビューを実施する。
計測: パフォーマンス改善を目指す場合は、リファクタリング前後のベンチマークを取得する。
後方互換性: APIの変更など、外部（もしあれば）やフロントエンドに影響がある場合は、互換性に注意するか、バージョン管理を行う。
